/////////////////////////////////////////////////////////////////////////////////////
Old King Code
/////////////////////////////////////////////////////////////////////////////////////
if (state[row][column].isNotOccupied()) {
      if (this.column != column && this.row != row) {
        if ((this.column + 1 == column) || (this.column - 1 == column)) {
          if ((this.row + 1 == row) || (this.row - 1 == row )) {
            return true;
          }
        } 
      } else if((this.column != column) && (this.row == row) ) {
        if(this.column + 1 == column || this.column - 1 == column) {
          return true;
        } 
      } else if((this.column == column) && (this.row != row)) {
        if ((this.row + 1 == row) || (this.row - 1 == row )) {
            return true;
        } 
      } 
    } else {
      Piece p = state[row][column].getPiece();
      if(p.getTeam() != this.team) {
        return true;
      } 
    }
    return false;
/////////////////////////////////////////////////////////////////////////////////////
Old Bishop Code
/////////////////////////////////////////////////////////////////////////////////////
System.out.println("Move method is being called");
    this.yDistance = y - super.column;
    System.out.println(yDistance);
    int xInt = super.row;
    int yInt = super.column;

    if (getSlope(x, y) == 1.0) {
      for (int i = 0; i < Math.abs(yDistance); i++) {
        if (x < super.row && y > super.column) {
          xInt--;
          yInt++;
        } else if (x < super.row && y < super.column) {
          xInt--;
          yInt--;
        } else if (x > super.row && y > super.column) {
          xInt++;
          yInt++;
        } else if (x > super.row && y < super.column) {
          xInt++;
          yInt--;
        } else if (state[xInt][yInt].isNotOccupied() == false) {
          System.out.println("occupied in between");
          return false;
        } 
        else{
          return true;
        }
      }
    } 
    else if (getSlope(x, y) != 1.0) {
      System.out.println("Not a diagonal move");
      return false;
    }
    return true;

/////////////////////////////////
Old getslope method
/////////////////////////////////
private double getSlope(int x, int y) {
    double slope = Math.abs((double) (y - super.column) / (x - super.row));
    return slope;
  }
/////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////
Old Rook Code
/////////////////////////////////////////////////////////////////////////////////////
if (state[x][y].isNotOccupied()) {
      if (super.row != x && super.column != y) {
        return false;
      } else if (super.row != x && super.column == y) {
        if (row < x) {
          for (int i = super.row; i < x; i++) {
            if (state[i][y].isNotOccupied() == false) {
              return false;
            } else if (x - 1 == i) {
              return true;
            }
          }
        } else if (super.row > x) {
          for (int i = super.row; i > x; i--) {
            if (state[i][y].isNotOccupied() == false) {
              return false;
            } else if (x - 1 == i) {
              return true;
            }
          }
        }
        return true;
      } else {
        return true;
      }


    else if (super.row == x && super.column != y) {
      if (super.column > y) {
        for (int i = super.column; i > y; i--) {
          if (state[x][i].isNotOccupied() == false) {
            return false;
          }
        }
      } else if (super.column < y) {
        for (int i = super.column; i < y; i++) {
          if (state[x][i].isNotOccupied() == false) {
            return false;
          }
        }
      }
      return true;
    } else {
      return true;
    }
  }

/////////////////////////////////////////////////////////////////////////////////////
Old Pawn Code
/////////////////////////////////////////////////////////////////////////////////////
if (state[row][column].isNotOccupied()) {
      if (super.column == column) {
        if ((super.row + 2 == row) && super.team == true && firstMove) {
          if (state[super.row + 1][column].isNotOccupied()) {
            firstMove = false;
            return true;
          } else {
            return false;
          }
        } else if ((super.row + 1 == row) && (super.team == true)) {
          firstMove = false;
          return true;
        }
        if ((super.row - 2 == row) && super.team == false && firstMove) {
          if (state[super.row - 1][column].isNotOccupied()) {
            firstMove = false;
            return true;
          } else {
            return false;
          }
        } else if ((super.row - 1 == row) && (super.team == false)) {
          firstMove = false;
          return true;
        }
      }
      return false;
    } else {
      Piece p = state[row][column].getPiece();
      if (super.team != p.getTeam()) {
        if (super.team) {
          if ((super.row + 1 == row) && ((super.column + 1 == column) || (super.column - 1 == column))) {
            return true;
          } else {
            return false;
          }
        } else {
          if ((super.row - 1 == row) && ((super.column + 1 == column) || (super.column - 1 == column))) {
            return true;
          } else {
            return false;
          }
        }
      } else {
        return false;
      }
    }

/////////////////////////////////////////////////////////////////////////////////////
Old Queen Code
/////////////////////////////////////////////////////////////////////////////////////
System.out.println("Move method is being called");
    this.yDistance = y - super.column;
    int xInt = super.row;
    int yInt = super.column;

    if (getSlope(x, y) == 1.0) {
      for (int i = 0; i < Math.abs(yDistance); i++) {
        if (x < super.row && y > super.column) {
          xInt--;
          yInt++;
        } else if (x < super.row && y < super.column) {
          xInt--;
          yInt--;
        } else if (x > super.row && y > super.column) {
          xInt++;
          yInt++;
        } else if (x > super.row && y < super.column) {
          xInt++;
          yInt--;
        }
        else if(x > super.row && y == super.column){
          xInt++;
        }
        else if(x < super.row && y == super.column){
          xInt--;
        }
        else if(x == super.row && y > super.column){
          yInt++;
        }
        else if(x == super.row && y < super.column){
          yInt--;
        }
      }
    } 
    else if (state[xInt][yInt].isNotOccupied() == false) {
          System.out.println("occupied in between");
          return false;
        } 
    return true;

/////////////////////////////////////////////////////////////////////////////////////
Old Knight Code
/////////////////////////////////////////////////////////////////////////////////////
if (state[x][y].isNotOccupied() == true) {
      if (super.column + 2 == y || super.column - 2 == y) {
        if (super.row + 1 == x || super.row - 1 == x) {
          return true;
        } else {
          return false;
        }
      } else if (super.column + 1 == y || super.column - 1 == y) {
        if (super.row + 2 == x || super.row - 2 == x) {

          return true;
        } else {
          return false;
        }
      }

      else if (super.row + 1 == x || super.row - 1 == x) {
        if (super.column + 2 == y || super.column - 2 == y) {

          return true;
        } else {
          return false;
        }
      } else if (super.row + 2 == x || super.row - 2 == x) {
        if (super.column + 1 == y || super.column - 1 == y) {

          return true;
        } else {
          return false;
        }
      } else {

        return false;
      }
    }

    else {
      return false;
    }

/////////////////////////////////////////////////////////////////////////////////////
Old Board Code
/////////////////////////////////////////////////////////////////////////////////////
package edu.bothell.chess;
import java.util.*;



public class Board {

  Square[][] state = new Square[8][8];
  ArrayList<Piece> Captured = new ArrayList<Piece>();
  ArrayList<Piece> Pieces;
  Boolean currentTeam = false;
  Scanner scn = new Scanner(System.in);

  public Board(ArrayList<Piece> Pieces) {
    this.Pieces = Pieces;
    this.updateState();
  }

  public void Draw() {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        System.out.print(state[i][j]);
      }
      System.out.println();
      System.out.println();
    }
  }

  public void updateState() {
    for (int i = 0; i < 8; i++) {
      for (int j = 0; j < 8; j++) {
        Square meSquare = new Square();
        state[i][j] = meSquare;
        for (Piece p : Pieces) {
          if ((p.getRow() == i) && (p.getColumn() == j)) {
            meSquare.setPiece(p);
            state[i][j] = meSquare;
          }
        }
      }
    }
    this.Draw();
  }

  public Piece selectPiece() {
    boolean invalid = true;
    while (invalid) {
      System.out.println("Please select a valid piece to move");
      String response = scn.next();
      for (Piece p : Pieces) {
        if(response.contains(",")) {
          int column = Integer.parseInt(response.substring(response.indexOf(",") + 1)) - 1;
          int row = Integer.parseInt(response.substring(0, response.indexOf(","))) - 1;
          if((p.getRow() == row && p.getColumn() == column) && currentTeam == p.getTeam()) {
            return p;
          }
        }
        if (p.getPieceID().equals(response) && currentTeam == p.getTeam()) {
          return p;
        }
      }
    }
    return null;
  }

  public void switchTeam() {
    this.currentTeam = !currentTeam;
  }

  public void move() {
    Piece p = this.selectPiece();
    boolean invalidMove = true;
    while (invalidMove) {
      System.out.println("Where would you like the piece to go? (row,column) or 'back' to select another piece.");
      String response = scn.next();
      if (response.equals("back")) {
        p = this.selectPiece();
      } else {
        int row = Integer.parseInt(response.substring(0, response.indexOf(","))) - 1;
        int column = Integer.parseInt(response.substring(response.indexOf(",") + 1)) - 1;
        Boolean valid = p.validateMove(row, column, state);
        if (valid) {
          p.setRow(row);
          p.setColumn(column);
          this.takePiece(p);
          invalidMove = false;
        } 
        else if (valid == false){
          System.out.println("Invaild Move");
        }
      }

    }
  }

  public void takePiece(Piece p1) {
    Piece temp = null;
    for (Piece p : Pieces) {
        if (p1.getRow() == p.getRow() && p1.getColumn() == p.getColumn()) {
          if (p1.getTeam() != p.getTeam()) {
            temp = p;
            Captured.add(p);
          }
        }
    }
    Pieces.remove(temp);
  }

}
/////////////////////////////////////////////////////////////////////////////////////